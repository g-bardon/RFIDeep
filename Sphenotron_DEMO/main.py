# This Python file uses the following encoding: utf-8
import sys

import pandas as pd
from PyQt5.QtWidgets import QApplication, QWidget, QAbstractItemView, QTreeWidgetItem, QVBoxLayout, QWidgetAction, QMenu
from PyQt5.QtCore import Qt, pyqtSlot
# ui
from mysql_connection.mysql_connection import *
from mainWidget_view import *
from qt_material import apply_stylesheet
from db_managment.modify_bird_functions import *
from db_managment.add_bird_functions import *
from db_managment.import_data_csv_functions import *

# models
from mysql_queries.queries_search import *
from mysql_queries.queries_info import *

# packages
from pymysql import *
import csv
import re
from animalWidget import *

class sphenotron(QWidget, Ui_Widget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.app = QApplication.instance()


        # get the saved files in memory
        self.settings_search = QSettings("sphenotron", "search")
        self.settings_file = QSettings("sphenotron", "files")
        self.settings_light_theme = QSettings("sphenotron", "theme")

        # change this to choose density of widget in UI
        self.extra = {'density_scale': '-1'}

        # Initialize the theme
        if self.settings_light_theme.value('theme'):
            apply_stylesheet(self.app, 'light_orange.xml', invert_secondary=True, extra=self.extra)
        else:
            apply_stylesheet(self.app, 'dark_amber.xml', invert_secondary=False, extra=self.extra)

        # Extract connection configuration and return error if the database is not found
        extract_config()
        if connect_to_db() == "Error":
            QMessageBox.information(self, 'Error', "Error with database connection")
            return

        # get instance of the UI (only view, no signals), from mainWidget_view.py (generated by QT Creator)
        self.ui = Ui_Widget()
        self.ui.setupUi(self) #this step take the longest time in launching the application (~90%)

        ### To add icon on top bar
        self.setWindowIcon(QtGui.QIcon('sphenotron.svg'))
        flags = Qt.WindowFlags()
        self.setWindowFlags(flags)

        # initialize view and signals
        self.init_view()
        self.init_signals()


    def init_view(self):
        """ This function initialize the view by hiding and showing the default filter buttons"""
        self.ui.tabWidget.setCurrentIndex(0)
        self.ui.sexFrame.hide()
        self.ui.current_locFrame.hide()
        self.ui.alarmsFrame.hide()
        self.ui.rfid_dateFrame.hide()
        self.ui.last_detectFrame.hide()
        self.ui.detect_dateFrame.hide()
        self.ui.commentFrame.hide()
        self.ui.customqueryFrame.hide()
        self.ui.deadFrame.hide()
        self.date_view_filter_date()

        self.ui.opencycleButton.hide()
        self.ui.opencycle_single_tabButton.hide()
        self.ui.number_selectionLabel.hide()

        # initialize manipulation tree in search tab
        self.init_manips()
        # populate alarm combobox tree in search tab
        self.init_alarms()

        # Initialize tabs of 'database managment'
        init_modif(self.ui)
        init_add_bird(self.ui)
        init_import_csv(self.ui)

        self.ui.rfidEdit.setText(self.settings_search.value("rfid"))
        self.ui.nameEdit.setText(self.settings_search.value("name"))
        self.modif_signals_exist = False

        if self.settings_light_theme.value('theme'):
            self.ui.dark_modeButton.setChecked(0)
        else:
            self.ui.dark_modeButton.setChecked(1)

    def init_signals(self):
        """ This function create the signals"""
        self.ui.alarmsCheckBox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.sexCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.last_detectCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.rfid_dateCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.current_locCheckBox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.customCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.deadCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.detect_dateCheckbox.toggled.connect(self.filters_checkboxes_changed)
        self.ui.commentCheckbox.toggled.connect(self.filters_checkboxes_changed)

        self.ui.rfid_dateComboBox.currentIndexChanged.connect(self.date_view_filter_date)
        self.ui.last_detectComboBox.currentIndexChanged.connect(self.date_view_filter_date)
        self.ui.detect_dateComboBox.currentIndexChanged.connect(self.date_view_filter_date)

        self.ui.ok_searchButton.clicked.connect(self.ok_searchButton_clicked)
        self.ui.reset_filtersButton.clicked.connect(self.reset_filter)

        self.ui.opencycleButton.clicked.connect(self.openSelectedCycles_diftab)
        self.ui.opencycle_single_tabButton.clicked.connect(self.openSelectedCycles_singletab)
        self.ui.resultSearchTable.cellDoubleClicked.connect(self.openSelectedCycles_diftab)
        self.ui.checkpairs_csvPushButton.clicked.connect(self.check_pairs_csv)

        self.ui.tabWidget_2.tabCloseRequested.connect(self.ui.tabWidget_2.removeTab)

        self.ui.rfid_import_csvButton.clicked.connect(self.rfid_import_csvButton_clicked)
        self.ui.name_import_csvButton.clicked.connect(self.name_import_csvButton_clicked)

        self.ui.ok_modifButton.clicked.connect(self.init_db_managment_modify_bird)
        init_signals_add_bird(self.ui)

        self.ui.dark_modeButton.toggled.connect(self.dark_modeButtonClicked)
        self.ui.export_correctionButton.clicked.connect(self.export_correctionButtonClicked)

        # Connect the messageReceived signal to switch tabs in case the Spheno is already open:
        self.app.messageReceived.connect(self.switch_tab)

    def switch_tab(self, msg):
        print("Switching tabs...:")
        print(msg)
        self.open_cycle_tab(msg)

    def _sigint_handler(self, signal, frame):
        print("Keyboard interrupt caught, running close handlers...")
        self.app_is_exiting()
        sys.exit(0)

    ### SEARCH MANAGMENT TAB ###

    def init_manips(self):
        """ Populates the manipulation tree thanks to a query in the database: get_manips()"""
        manips = pd.DataFrame(get_manips())
        manip_classes = pd.DataFrame(get_manip_classes())['class']

        for manip_class in manip_classes:
            parent = QTreeWidgetItem(self.ui.manipsTreeWidget)
            parent.setText(0, manip_class)
            parent.setFlags(parent.flags() | Qt.ItemIsAutoTristate | Qt.ItemIsUserCheckable)
            for manip in manips.loc[manips['class'] == manip_class, 'name']:
                child = QTreeWidgetItem(parent)
                child.setFlags(child.flags() | Qt.ItemIsUserCheckable)
                child.setText(0, manip)
                child.setCheckState(0, Qt.Unchecked)

        self.ui.manipsTreeWidget.show()

    def init_alarms(self):
        """ Populates the alarm combobox thanks to a query in the database: get_alarms()"""
        alarms = get_alarms()
        self.ui.alarmsComboBox.addItem('No alarm')
        for al in alarms:
            self.ui.alarmsComboBox.addItem(al['class'])

    def date_view_filter_date(self):
        """manage view of qdateedit widgets in search tab"""
        if self.ui.rfid_dateComboBox.currentText() == 'Between':
            self.ui.rfid_date_andLabel.show()
            self.ui.rfid_date_bewteenDateEdit.show()
        else:
            self.ui.rfid_date_andLabel.hide()
            self.ui.rfid_date_bewteenDateEdit.hide()

        if self.ui.last_detectComboBox.currentText() == 'Between':
            self.ui.last_detect_andLabel.show()
            self.ui.last_detect_betweenDateEdit.show()
        else:
            self.ui.last_detect_andLabel.hide()
            self.ui.last_detect_betweenDateEdit.hide()

        if self.ui.detect_dateComboBox.currentText() == 'Between':
            self.ui.detect_date_andLabel.show()
            self.ui.detect_date_bewteenDateEdit.show()
        else:
            self.ui.detect_date_andLabel.hide()
            self.ui.detect_date_bewteenDateEdit.hide()

    def ok_searchButton_clicked(self):
        """ Execute the search in the database according to the selected filters"""
        self.ui.resultSearchTable.setSortingEnabled(False) ### line to avoid a known problem of pyqt when cells are sorted and then items are added
        self.ui.resultSearchTable.setRowCount(0)
        columns = ["Name", "RFID", "Manipulations", "Alarm", "RFID date", "Last detection", "Sex"]
        self.ui.resultSearchTable.setColumnCount(7)
        self.ui.resultSearchTable.setHorizontalHeaderLabels(columns)

        # Get final MySQL query according to selected filters
        query = self.get_finalquery_from_filter()
        query = "SELECT D.*, M.manip_rfid from (" + query + \
                ") AS D LEFT OUTER JOIN (SELECT rfid ,GROUP_CONCAT(' ', manip) as manip_rfid FROM bird_manips GROUP BY rfid) as M ON D.rfid = M.rfid ORDER BY name ASC"
        print(query)
        datas = execute_fetchall(query)

        if datas == "Error":
            QMessageBox.information(self, 'Error', "Check your query")
            return
        if datas is None:
            return

        total = len(datas)
        self.ui.resultSearchTable.setRowCount(total)

        sexes = [x["sex"] for x in datas]
        males = sexes.count("M")
        females = sexes.count("F")
        indeterminated = len(datas) - males - females

        #populate result table
        for line, data in enumerate(datas):
            self.ui.resultSearchTable.setItem(line, 0, QTableWidgetItem(data["name"]))
            self.ui.resultSearchTable.setItem(line, 1, QTableWidgetItem(data["rfid"]))
            self.ui.resultSearchTable.setItem(line, 2, QTableWidgetItem(data["manip_rfid"]))
            self.ui.resultSearchTable.setItem(line, 3, QTableWidgetItem(data["alarm"]))
            self.ui.resultSearchTable.setItem(line, 4, QTableWidgetItem(str(data["rfid_date"])))
            self.ui.resultSearchTable.setItem(line, 5, QTableWidgetItem(str(data["last_detection"]) if data["last_detection"] is not None else '' ))
            self.ui.resultSearchTable.setItem(line, 6, QTableWidgetItem(data["sex"]))

        self.ui.resultSearchTable.resizeColumnsToContents()
        self.ui.resultSearchTable.setColumnWidth(0, 140)
        self.ui.resultSearchTable.setColumnWidth(1, 200)
        self.ui.resultSearchTable.setColumnWidth(2,200)
        self.ui.resultSearchTable.setColumnWidth(5, 180)
        self.ui.resultSearchTable.setSortingEnabled(True)

        self.ui.opencycleButton.show()
        self.ui.opencycle_single_tabButton.show()
        self.ui.number_selectionLabel.show()

        self.ui.number_selectionLabel.setText(
                str(total) + " bird(s) : " + str(females) + " female(s), " + str(males) + " male(s), " + str(
                    indeterminated) + " unknown")

        # save rfid and name if in the filters
        self.settings_search.setValue("rfid", str(self.ui.rfidEdit.text()))
        self.settings_search.setValue("name", str(self.ui.nameEdit.text()))


    def get_arguments(self, indice):
        """ Get the value of selected filter.

        :param indice: name of the filter
        :return: argument in the mysql query
        """
        args = []

        # name
        if indice == "name":
            edit = self.ui.nameEdit.text()
            if edit.startswith(" "):
                temp = edit[1:]
            elif edit.endswith(" "):
                temp = edit[:-1]
            else:
                temp = edit
            args = temp.split(",")

        # RFID
        elif indice == "rfid":
            edit = self.ui.rfidEdit.text()
            if edit.startswith(" "):
                temp = edit[1:]
            elif edit.endswith(" "):
                temp = edit[:-1]
            else:
                temp = edit
            args = temp.split(",")

        # Dead
        elif indice == "dead":
            if self.ui.deadButton.isChecked():
                args.append(1)
            elif self.ui.aliveButton.isChecked():
                args.append(0)

        # Current Location
        elif indice == "current_loc":
            if self.ui.colonyButton.isChecked():
                args.append("Mer")
            elif self.ui.seaButton.isChecked():
                args.append("Terre")

        # RFID date
        elif indice == 'rfid_date':
            text = ""
            if self.ui.rfid_dateComboBox.currentText() == "Before":
                text = "<= \"" + str(self.ui.rfid_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.rfid_dateComboBox.currentText() == "After":
                text = ">= \"" + str(self.ui.rfid_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.rfid_dateComboBox.currentText() == "Between":
                text = ">= \"" + str(self.ui.rfid_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
                text = "<= \"" + str(self.ui.rfid_date_bewteenDateEdit.date().toPyDate()) + "\""
                args.append(text)

        # Last detection date
        elif indice == 'last_detect':
            text = ""
            if self.ui.last_detectComboBox.currentText() == "Before":
                text = "<= \"" + str(self.ui.last_detectDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.last_detectComboBox.currentText() == "After":
                text = ">= \"" + str(self.ui.last_detectDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.last_detectComboBox.currentText() == "Between":
                text = ">= \"" + str(self.ui.last_detectDateEdit.date().toPyDate()) + "\""
                args.append(text)
                text = "<= \"" + str(self.ui.last_detect_betweenDateEdit.date().toPyDate()) + "\""
                args.append(text)

        # Detection date
        elif indice == "detect_date":
            text = ""
            if self.ui.detect_dateComboBox.currentText() == "Before":
                text = "<= \"" + str(self.ui.detect_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.detect_dateComboBox.currentText() == "After":
                text = ">= \"" + str(self.ui.detect_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
            elif self.ui.detect_dateComboBox.currentText() == "Between":
                text = ">= \"" + str(self.ui.detect_dateDateEdit.date().toPyDate()) + "\""
                args.append(text)
                text = "<= \"" + str(self.ui.detect_date_bewteenDateEdit.date().toPyDate()) + "\""
                args.append(text)

        # Sex
        elif indice == 'sex':
            if self.ui.femaleButton.isChecked():
                args.append('F')
            if self.ui.maleButton.isChecked():
                args.append('M')
            if self.ui.unknownButton.isChecked():
                args.append('Ukn')
            if self.ui.obs_maleButton.isChecked():
                args.append('obsM')
            if self.ui.obs_femaleButton.isChecked():
                args.append('obsF')

        # Comment
        elif indice == 'comment':
            args.append(str(self.ui.commentLineEdit.text()))

        # Manipulation
        elif indice == 'manip':
            list_manips = []
            for item in self.ui.manipsTreeWidget.findItems("", Qt.MatchContains | Qt.MatchRecursive):
                if item.checkState(0) == 2:
                    list_manips.append(item.text(0))
            args = list_manips


        # Alarm
        elif indice == 'alarm':
            args.append(self.ui.alarmsComboBox.currentText())

        # Custom query
        elif indice == 'custom_query':
            args.append(str(self.ui.customLineEdit.text()))

        return args

    def get_query(self, indice):
        """ Get the query of the filter index.

        :param indice: name of the selected filter
        :return: query"""

        # Name
        if indice == 'name':
            args = self.get_arguments('name')
            query = get_query_name(args)

        # RFID
        elif indice == 'rfid':
            args = self.get_arguments('rfid')
            query = get_query_rfid(args)

        # Dead
        elif indice == 'dead':
            args = self.get_arguments('dead')
            query = get_query_dead(args)

        # Current location
        elif indice == 'current_loc':
            args = self.get_arguments('current_loc')
            query = get_query_place(args)

        # RFID date
        elif indice == 'rfid_date':
            args = self.get_arguments('rfid_date')
            query = get_query_transp(args)

        # Last detection date
        elif indice == 'last_detect':
            args = self.get_arguments('last_detect')
            query = get_query_last_detect(args)

        # Detection date
        elif indice == 'detect_date':
            args = self.get_arguments('detect_date')
            query = get_query_detect(args)

        # Sex
        elif indice == 'sex':
            args = self.get_arguments('sex')
            query = get_query_sex(args)

        # Comment
        elif indice == 'comment':
            args = self.get_arguments('comment')
            query = get_query_comment(args)

        # Manipulation
        elif indice == 'manip':
            args = self.get_arguments('manip')
            args = [self.ui.criteria_manipButtonGroup.checkedButton().text()] + args
            query = get_query_manip(args)

        # Alarm
        elif indice == 'alarm':
            args = self.get_arguments('alarm')
            query = get_query_alarm(args)

        # Custom query
        elif indice == 'custom_query':
            args = self.get_arguments('custom_query')
            query = get_query_custom_query(args)

        return query

    def get_filters(self):
        # return list of selected filters

        filters = []
        if self.ui.nameEdit.text() != '':
            filters.append('name')
        if self.ui.rfidEdit.text() != '':
            filters.append('rfid')
        if self.ui.deadCheckbox.isChecked():
            filters.append('dead')
        if self.ui.current_locCheckBox.isChecked():
            filters.append('current_loc')
        if self.ui.rfid_dateCheckbox.isChecked():
            filters.append('rfid_date')
        if self.ui.last_detectCheckbox.isChecked():
            filters.append('last_detect')
        if self.ui.detect_dateCheckbox.isChecked():
            filters.append('detect_date')
        if self.ui.sexCheckbox.isChecked():
            filters.append('sex')
        if self.ui.commentCheckbox.isChecked():
            filters.append('comment')
        if self.ui.alarmsCheckBox.isChecked():
            filters.append('alarm')
        if self.ui.customCheckbox.isChecked():
            filters.append('custom_query')

        if  len([item for item in self.ui.manipsTreeWidget.findItems("", Qt.MatchContains | Qt.MatchRecursive) if item.checkState(0) == 2]):
            filters.append('manip')
        return filters

    def get_finalquery_from_filter(self):
        # return the final MySQL query from all selected filters
        filters = self.get_filters()
        sub_queries = []
        for filter in filters:
            sub_queries.append("(" + self.get_query(filter) + ")")
        beginning = "SELECT * FROM birds "
        end = ""
        if len(sub_queries) > 0:
            beginning += "WHERE"
            for index, sub_query in enumerate(sub_queries):
                suite = " rfid IN "
                end += suite + sub_query + " AND "
            query = beginning + end[:-5]  + " ORDER BY name ASC"
            return query
        else:
            query = beginning + " ORDER BY name ASC"
            return query

    def filters_checkboxes_changed(self):
        # manage view of filters
        if self.ui.sexCheckbox.isChecked():
            self.ui.sexFrame.show()
        else:
            self.ui.sexFrame.hide()

        if self.ui.alarmsCheckBox.isChecked():
            self.ui.alarmsFrame.show()
        else:
            self.ui.alarmsFrame.hide()

        if self.ui.last_detectCheckbox.isChecked():
            self.ui.last_detectFrame.show()
        else:
            self.ui.last_detectFrame.hide()

        if self.ui.rfid_dateCheckbox.isChecked():
            self.ui.rfid_dateFrame.show()
        else:
            self.ui.rfid_dateFrame.hide()

        if self.ui.current_locCheckBox.isChecked():
            self.ui.current_locFrame.show()
        else:
            self.ui.current_locFrame.hide()

        if self.ui.customCheckbox.isChecked():
            self.ui.customqueryFrame.show()
        else:
            self.ui.customqueryFrame.hide()

        if self.ui.deadCheckbox.isChecked():
            self.ui.deadFrame.show()
        else:
            self.ui.deadFrame.hide()

        if self.ui.detect_dateCheckbox.isChecked():
            self.ui.detect_dateFrame.show()
        else:
            self.ui.detect_dateFrame.hide()

        if self.ui.commentCheckbox.isChecked():
            self.ui.commentFrame.show()
        else:
            self.ui.commentFrame.hide()

    def reset_filter(self):
        # reset view of filters and selections
        self.ui.rfidEdit.setText('')
        self.ui.nameEdit.setText('')

        self.ui.alarmsCheckBox.setCheckState(0)
        self.ui.sexCheckbox.setCheckState(0)
        self.ui.last_detectCheckbox.setCheckState(0)
        self.ui.rfid_dateCheckbox.setCheckState(0)
        self.ui.current_locCheckBox.setCheckState(0)
        self.ui.customCheckbox.setCheckState(0)
        self.ui.deadCheckbox.setCheckState(0)
        self.ui.detect_dateCheckbox.setCheckState(0)
        self.ui.commentCheckbox.setCheckState(0)

        for item in self.ui.manipsTreeWidget.findItems("", Qt.MatchContains | Qt.MatchRecursive):
            if item.checkState(0) == 2:
                item.setCheckState(0,0)

    def openSelectedCycles_diftab(self):
        ## Allows opening cycles in different tabs (charge all cycle at the same time, may take some time if a large number of bird cycles are opened)
        list_rfid = self.ui.resultSearchTable.selectionModel().selectedRows()
        for i in list_rfid:
            row = i.row()
            rfid = self.ui.resultSearchTable.item(row, 1).text()
            self.open_cycle_tab(rfid)


    def openSelectedCycles_singletab(self):
        ## Allows opening cycles in a single table with the list of selected birds
        rows = self.ui.resultSearchTable.selectionModel().selectedRows()
        self.list_rfid = []
        self.list_name = []
        for i in rows:
            row = i.row()
            self.list_rfid.append(self.ui.resultSearchTable.item(row, 1).text())
            self.list_name.append(self.ui.resultSearchTable.item(row, 0).text())

        newtab = QtWidgets.QWidget()
        self.ui.tabWidget_2.addTab(newtab, "Multi cycles")
        self.ui.tabWidget.setCurrentIndex(1)
        self.ui.tabWidget_2.setCurrentIndex(self.ui.tabWidget_2.count() - 1)

        self.horizontalLayout = QtWidgets.QHBoxLayout(newtab)
        self.listwidgetlayout = QtWidgets.QVBoxLayout()
        self.widgetLayout = QtWidgets.QVBoxLayout()
        self.horizontalLayout.addLayout(self.listwidgetlayout)
        self.horizontalLayout.addLayout(self.widgetLayout)

        # cycles are vizualized in a stacked widget
        self.stackedWidget_rfid = QtWidgets.QStackedWidget()
        self.widgetLayout.addWidget(self.stackedWidget_rfid)

        self.pages = []
        self.index_pages_rfid = []
        self.pages.append(QtWidgets.QWidget())
        self.pages[0].setEnabled(True)
        self.index_pages_rfid.append(self.list_rfid[0])
        self.verticalLayout = QtWidgets.QVBoxLayout(self.pages[0])

        ### Instance of the cycle window is created here
        individual = animalWidget(rfid=self.list_rfid[0])
        individual.ui.modify_bird_dataButton.clicked.connect(lambda: self.modify_bird_dataButtonClicked(self.list_rfid[0]))

        self.verticalLayout.addWidget(individual)

        self.stackedWidget_rfid.addWidget(self.pages[0])
        self.stackedWidget_rfid.setCurrentIndex(0)

        self.listWidget = QtWidgets.QListWidget()
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.listWidget.setSizePolicy(sizePolicy)
        for name in self.list_name:
            self.listWidget.addItem(str(name))
        self.listwidgetlayout.addWidget(self.listWidget)

        self.listWidget.setCurrentRow(0)

        self.removeButton = QtWidgets.QPushButton('Remove selected')
        self.listwidgetlayout.addWidget(self.removeButton)

        self.add_list_alarm = QtWidgets.QPushButton('Put list under alarm')
        self.listwidgetlayout.addWidget(self.add_list_alarm)

        self.add_list_manip = QtWidgets.QPushButton('Add list to manip')
        self.listwidgetlayout.addWidget(self.add_list_manip)


        self.listWidget.itemSelectionChanged.connect(self.change_current_rfid_view)
        self.removeButton.clicked.connect(self.removeButtonClicked)
        self.add_list_alarm.clicked.connect(self.add_list_alarmClicked)
        self.add_list_manip.clicked.connect(self.add_list_manipClicked)

    def modify_bird_dataButtonClicked(self, rfid):
        self.ui.tabWidget.setCurrentIndex(2)
        self.ui.db_managment_tabWidget.setCurrentIndex(0)
        self.ui.rfid_modifLineEdit.setText(rfid)
        self.ui.ok_modifButton.click()

    def change_current_rfid_view(self, list_partner = None):
        # Selection of bird cycle in the list, keep in memory the cycles that have been already opened
        # Mode for partners
        row = self.listWidget.currentRow()
        pair_rfid = None
        if list_partner is None:
            rfid = self.list_rfid[row]
        else:
            rfid = list_partner[row][0]
            partner = list_partner[row][1]
            year = int(list_partner[row][2])
            pair_rfid = rfid+partner+str(year)

        if (rfid in self.index_pages_rfid) & (list_partner is None):
            self.stackedWidget_rfid.setCurrentIndex(self.index_pages_rfid.index(rfid))
            return

        elif (list_partner is not None) & (pair_rfid in self.index_pages_rfid):
            self.stackedWidget_rfid.setCurrentIndex(self.index_pages_rfid.index(pair_rfid))
        else:
            self.pages.append(QtWidgets.QWidget())
            self.pages[-1].setEnabled(True)
            self.verticalLayout = QtWidgets.QVBoxLayout(self.pages[-1])
            if list_partner is None:
                individual = animalWidget(rfid=rfid)
                index_rfid = rfid
                self.index_pages_rfid.append(index_rfid)
            else:
                individual = animalWidget(rfid=rfid, partner=partner)
                index_rfid = rfid+partner+str(year)
                self.index_pages_rfid.append(index_rfid)
                start_date = datetime(year - 1, 10, 1)
                end_date = datetime(year, 3, 1)
                zoom = [start_date.timestamp(), end_date.timestamp()]
                individual.viewbox.setXRange(zoom[0], zoom[1])
                individual.zoom_graph()
            self.verticalLayout.addWidget(individual)
            self.stackedWidget_rfid.addWidget(self.pages[-1])
            self.stackedWidget_rfid.setCurrentIndex(self.index_pages_rfid.index(index_rfid))
            individual.ui.modify_bird_dataButton.clicked.connect(lambda: self.modify_bird_dataButtonClicked(rfid))

    def removeButtonClicked(self):
        """ Remove an element from the left panel list in Cycle Tab"""
        if self.listWidget.count() > 1:
            self.listWidget.takeItem(self.listWidget.currentRow())
            del(self.list_rfid[self.listWidget.currentRow()])

    def add_list_alarmClicked(self):
        """ Put the left panel list of birds under chosen alarm"""
        self.add_list_alarm.hide()
        self.add_list_manip.hide()

        alarm_list = get_alarms()
        self.combobox_alarms = QtWidgets.QComboBox()
        self.combobox_alarms.addItem('No alarm')
        for alarm in alarm_list:
            self.combobox_alarms.addItem(alarm['class'])
        self.listwidgetlayout.addWidget(self.combobox_alarms)

        self.save_add_alarm = QtWidgets.QPushButton('Save')
        self.listwidgetlayout.addWidget(self.save_add_alarm)
        self.cancel_add_alarm = QtWidgets.QPushButton('Cancel')
        self.listwidgetlayout.addWidget(self.cancel_add_alarm)

        self.save_add_alarm.clicked.connect(self.save_add_alarmClicked)
        self.cancel_add_alarm.clicked.connect(self.cancel_add_alarmClicked)

    def add_list_manipClicked(self):
        """ Add the left panel list of birds to a manipulation"""
        self.add_list_alarm.hide()
        self.add_list_manip.hide()

        manip_list = get_manips()
        self.combobox_manips = QtWidgets.QComboBox()
        for manip in manip_list:
            self.combobox_manips.addItem(manip['name'])
        self.listwidgetlayout.addWidget(self.combobox_manips)

        self.save_add_manip = QtWidgets.QPushButton('Save')
        self.listwidgetlayout.addWidget(self.save_add_manip)
        self.cancel_add_manip = QtWidgets.QPushButton('Cancel')
        self.listwidgetlayout.addWidget(self.cancel_add_manip)

        self.save_add_manip.clicked.connect(self.save_add_manipClicked)
        self.cancel_add_manip.clicked.connect(self.cancel_add_manipClicked)

    def save_add_alarmClicked(self):
        """ Save function to put the left panel list of birds under chosen alarm"""
        alarm = self.combobox_alarms.currentText()
        if alarm == 'No alarm':
            alarm = 'Null'
        else:
            alarm = "'{}'".format(alarm)
        for rfid in self.list_rfid:
            execute_commit("UPDATE birds SET alarm = {} where rfid = '{}'".format(alarm, rfid))
        self.index_pages_rfid = []
        for page in range(len(self.pages)):
            self.stackedWidget_rfid.removeWidget(self.pages[page])
        self.change_current_rfid_view()
        self.cancel_add_alarmClicked()

    def cancel_add_alarmClicked(self):
        """ Cancel function to put the left panel list of birds under chosen alarm"""
        self.save_add_alarm.close()
        self.cancel_add_alarm.close()
        self.combobox_alarms.close()
        self.add_list_alarm.show()
        self.add_list_manip.show()

    def save_add_manipClicked(self):
        """ Save function to add the left panel list of birds to a manipulation"""
        manip = self.combobox_manips.currentText()
        for rfid in self.list_rfid:
            execute_commit("INSERT INTO bird_manips (rfid, manip) VALUES ('{}','{}')".format(rfid, manip))
        self.index_pages_rfid = []
        for page in range(len(self.pages)):
            self.stackedWidget_rfid.removeWidget(self.pages[page])
        self.change_current_rfid_view()
        self.cancel_add_manipClicked()

    def cancel_add_manipClicked(self):
        """ Concel function to add the left panel list of birds to a manipulation"""
        self.save_add_manip.close()
        self.cancel_add_manip.close()
        self.combobox_manips.close()
        self.add_list_alarm.show()
        self.add_list_manip.show()

    def open_cycle_tab(self, rfid):
        """Open cycle in a new tab"""
        if len(execute_fetchall("SELECT rfid FROM birds WHERE rfid = '{}'".format(rfid))):
            newtab = QtWidgets.QWidget()
            self.ui.tabWidget_2.addTab(newtab, str(rfid))
            individual = animalWidget(rfid=rfid)
            individual.ui.modify_bird_dataButton.clicked.connect(lambda: self.modify_bird_dataButtonClicked(rfid))
            self.ui.tabWidget.setCurrentIndex(1)
            self.horizontalLayout = QtWidgets.QHBoxLayout(newtab)
            self.widgetLayout = QtWidgets.QVBoxLayout()
            self.horizontalLayout.addLayout(self.widgetLayout)
            self.widgetLayout.addWidget(individual)
            self.ui.tabWidget_2.setCurrentIndex(self.ui.tabWidget_2.count() - 1)


    def name_import_csvButton_clicked(self):
        """ import list of names from csv file. First column, header 'name' or None """

        text = ""
        last_path = self.settings_file.value("last_file_name")
        if last_path is None:
            fichier = QFileDialog.getOpenFileName(self, "Choose a file", filter="*.csv")
        else:
            fichier = QFileDialog.getOpenFileName(self, "Choose a file", last_path, filter="*.csv")
        if fichier[0]:
            self.settings_file.setValue("last_file_name", str(fichier[0]))
            with open(fichier[0], 'r') as csvfile:
                spamreader = csv.reader(csvfile)
                for row in spamreader:
                    if row[0] == 'name':
                        continue
                    row_ok = re.split(r'[ ,|;"]+', row[0])
                    text += row_ok[0] + ","
                self.ui.nameEdit.setText(text[:-1])

    def rfid_import_csvButton_clicked(self):
        """ import list of rfid from csv file. First column, header 'rfid' or None """

        text = ""
        last_path = self.settings_file.value("last_file_rfid")
        if last_path is None:
            fichier = QFileDialog.getOpenFileName(self, "Choose a file", filter="*.csv")
        else:
            fichier = QFileDialog.getOpenFileName(self, "Choose a file", last_path, filter="*.csv")
        if fichier[0]:
            self.settings_file.setValue("last_file_rfid", str(fichier[0]))
            with open(fichier[0], 'r') as csvfile:
                spamreader = csv.reader(csvfile)
                for row in spamreader:
                    if row[0] == 'rfid':
                        continue
                    row_ok = re.split(r'[,|;"]+', row[0])
                    text += row_ok[0] + ","
                self.ui.rfidEdit.setText(text[:-1])


    ### DATABASE MANAGMENT TAB ###

        # MODIFY BIRDS #

    def init_db_managment_modify_bird(self):
        # Initialize 'modify bird' tab with functions of modify_bird_functions.py
        data_rfid = execute_fetchall("SELECT * FROM birds WHERE rfid = '{}'".format(self.ui.rfid_modifLineEdit.text()))
        if data_rfid:
            data_rfid = data_rfid[0]
            rfid = self.ui.rfid_modifLineEdit.text()

            init_data_rfid(self.ui, data_rfid)

            init_manip_rfid(self.ui)

            comments = get_comments(rfid)
            init_comments_rfid(self.ui, comments)

            init_events(self.ui)
            init_measures(self.ui)

            if self.modif_signals_exist:
                disconnect_signals(self.ui)

            init_signals(self.ui)

            self.modif_signals_exist = True

        else:
            QMessageBox.information(self, 'Error', "Unknown RFID")

    #### OPTIONS TAB ####

    def check_pairs_csv(self):
        ## Open pairs of individual in cycle tabs, automatically zoom on the year
        ## Need a csv file with 1st column RFID #1, 2nd column RFID #2 3rd column YEAR
        file = QFileDialog.getOpenFileName(self, "Choose a file", filter="*.csv")
        if not file[0]:
            return
        list_pairs = []
        with open(file[0], 'r') as csvfile:
            spamreader = csv.reader(csvfile)
            for row in spamreader:
                if ((row[0][0] != 'A') & (row[0][0] != 'R')):
                    continue
                # row_ok = re.split(r'[,|;"]+', row[0])
                name1 = execute_fetchall("SELECT name FROM birds WHERE rfid = '{}'".format(row[0]))
                if name1:
                    name1 = name1[0]['name']
                    name2 = execute_fetchall("SELECT name FROM birds WHERE rfid = '{}'".format(row[1]))
                    if name2:
                        name2 = name2[0]['name']
                        list_pairs.append([row[0], row[1], row[2], name1, name2])

        newtab = QtWidgets.QWidget()
        self.ui.tabWidget_2.addTab(newtab, "Multi pairs")
        self.ui.tabWidget.setCurrentIndex(1)
        self.ui.tabWidget_2.setCurrentIndex(self.ui.tabWidget_2.count() - 1)

        self.horizontalLayout = QtWidgets.QHBoxLayout(newtab)
        self.listwidgetlayout = QtWidgets.QVBoxLayout()
        self.widgetLayout = QtWidgets.QVBoxLayout()
        self.horizontalLayout.addLayout(self.listwidgetlayout)
        self.horizontalLayout.addLayout(self.widgetLayout)

        self.stackedWidget_rfid = QtWidgets.QStackedWidget()
        self.widgetLayout.addWidget(self.stackedWidget_rfid)

        self.pages = []
        self.index_pages_rfid = []
        self.pages.append(QtWidgets.QWidget())
        self.pages[0].setEnabled(True)
        self.index_pages_rfid.append(list_pairs[0][0])
        self.verticalLayout = QtWidgets.QVBoxLayout(self.pages[0])
        individual = animalWidget(rfid=list_pairs[0][0], partner = list_pairs[0][1])
        start_date = datetime(int(list_pairs[0][2])-1, 10,1)
        end_date = datetime(int(list_pairs[0][2]), 3, 1)
        zoom = [start_date.timestamp(), end_date.timestamp()]
        individual.viewbox.setXRange(zoom[0], zoom[1])
        individual.zoom_graph()
        individual.ui.modify_bird_dataButton.clicked.connect(lambda: self.modify_bird_dataButtonClicked(list_pairs[0][0]))
        self.verticalLayout.addWidget(individual)

        self.stackedWidget_rfid.addWidget(self.pages[0])
        self.stackedWidget_rfid.setCurrentIndex(0)

        self.listWidget = QtWidgets.QListWidget()
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.listWidget.setSizePolicy(sizePolicy)
        for pair in list_pairs:
            self.listWidget.addItem(str(pair[3])+' + ' + str(pair[4]))
        self.listwidgetlayout.addWidget(self.listWidget)

        self.listWidget.setCurrentRow(0)
        self.listWidget.itemSelectionChanged.connect(lambda: self.change_current_rfid_view(list_pairs))


    def dark_modeButtonClicked(self):
        """Change the theme"""
        if self.ui.dark_modeButton.isChecked():
            apply_stylesheet(self.app, 'dark_amber.xml', invert_secondary=False, extra=self.extra)
            self.settings_light_theme.setValue("theme", 0)
        else:
            apply_stylesheet(self.app, 'light_orange.xml', invert_secondary=True, extra=self.extra)
            self.settings_light_theme.setValue("theme", 1)

    def export_correctionButtonClicked(self):
        """Run correction of detections for all birds and save in CSV file"""
        path_csv = QtWidgets.QFileDialog.getSaveFileName(self, 'Choose the file...', 'corrected_detections', "csv(*.csv)")
        if path_csv[0] != '':
            db = settings_connexion.value("database")
            detections = execute_fetchall("SELECT rfid, dtime, antenna_id, \"original\" as \"type\" FROM detections WHERE dtime is not Null")
            list_rfid = set([x['rfid'] for x in detections])
            c=0
            for rfid in list_rfid:
                print(rfid + ' - ' + f'{c}/{len(list_rfid)}')
                c+=1
                det_to_correct = [x for x in detections if x['rfid'] == rfid]
                correction = fill_gaps(rfid=rfid, bd = db, detections=det_to_correct)
                detections += correction
            detections = pd.DataFrame(detections)
            detections = detections.sort_values(by=['rfid', 'dtime'])
            detections.to_csv(path_csv[0], index=False)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    widget = sphenotron()
    widget.show()
    sys.exit(app.exec())
